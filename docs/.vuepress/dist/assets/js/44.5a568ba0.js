(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{327:function(t,s,a){"use strict";a.r(s);var v=a(14),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"作用域-作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域-作用域链"}},[t._v("#")]),t._v(" 作用域&作用域链")]),t._v(" "),s("h2",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),s("p",[t._v("作用域决定了代码区块中变量和其他资源的可见性。"),s("br"),t._v("\n作用域让变量不会暴露出去，即隔离变量，让不在作用域下的执行上下文无法访问。")]),t._v(" "),s("p",[t._v("ES6 之前只有全局作用域和函数作用域，ES6 引入了 "),s("code",[t._v("let")]),t._v(" 和 "),s("code",[t._v("const")]),t._v(" , 提供了块级作用域。")]),t._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("从当前作用域开始，一层一层往上找某个变量。如果全局作用域中也找不到，就放弃寻找。这种层级关系就是作用域链。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("由多个执行上下文的 "),s("strong",[t._v("变量对象（VO）")]),t._v(" 构成的链就叫做作用域链，通过这条链去寻找变量。")])]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("js 采用的是静态作用域链，所以函数的作用域在 "),s("strong",[t._v("函数定义")]),t._v(" 的时候就已经确定了。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);